---
layout: post
title: IL2CPP OPTIMIZATIONS
description: "IL2CPP OPTIMIZATIONS"
tags: [IL2CPP Unity optimizations]
---

----------------------

这篇文章给我最大的想法是：“executing no code is better than executing some code.” 不做任何无关事情是最好的。化繁为简。回想起来之前的做变灰的shader，应该把shader分成两份，变灰和不变灰，不需要有便会的时候因为GPU对分枝预测能力比CPU要弱的多，花费的代价也更大。

------------

前面的[文章]讨论过调用虚拟方法比直接函数调用要更慢，而且介绍了如何将调用虚函数变为直接调用函数。但是当我们必须调用虚函数的时候，IL2CPP必须让它仅可能的运行的快。

### **What does it take to make a virtual method call?**

调用虚函数的时候，做了什么。

A virtual method call is a call that must be resolved at run time. The compiler does not know which method will be called when it compiles the code, so it builds an array of methods (called the virtual table, or vtable) for each class. When someone calls one of those methods, the runtime looks up the proper method in the vtable, and calls it. But what happens when things don’t work out, and there is no virtual method to call in the vtable?

虚函数调用必须在运行时才能被解析怎么调用。编译器在编译事情不知道具体是调用什么函数，所以它为每个类建立了一个函数数组（叫做虚函数表，or vtable）。当有人调用虚函数的时候，运行时会在vtable查找合适的函数后调用它。但是如果没有找到这个虚函数的时候，会发生什么呢？

### **When virtual methods go bad**

Let’s look at an extreme example, where the object we use has a *type* created at run time:

我们看看一个极端的例子，我们用type去创建实例。

![Smaller icon](http://amgoodlife.top/images/11/baseclass.png)

Given these types, we can try this code in Unity (I’m using version 5.3.5):

基于上面的例子，我用Unity5.3.5来做实验。

![Smaller icon](http://amgoodlife.top/images/11/vie.png)

The details of MakeRuntimeBaseClass are not too important. What really matters is the object it creates has a type (GenericDerivedClass<int>) which is created at run time.

This somewhat odd code is no problem for a Just-in-time (JIT) compiler, where the compilation work happens at runtime. If we run it in the Unity editor, we get:

MakeRuntimeBaseClass的细节没那么重要。真正有用的资料是：运行时创建了一个类型 (GenericDerivedClass<int>) 

有些有趣的事情会发生，代码在JIT（看[这里]）编译器里没问题，因为是运行时完成编译的。比如我们在Unity的编辑器里运行，我们得到：

![Smaller icon](http://amgoodlife.top/images/11/unityeditor.png)

但是故事在AOT里编辑器却不一样。如果我们在iOS上采用IL2CPP运行相同的代码，我们会得到下面的异常：

ExecutionEngineException: Attempting to call method 'GenericDerivedClass`1[[System.Int32, mscorlib, Version=2.0.5.0,     Culture=, PublicKeyToken=7cec85d7bea7798e]]::SayHello' for which no ahead of time (AOT) code was generated.  at VirtualInvokeExample.Start () [0x00000] in <filename unknown>:0 

That type created at runtime (GenericDerivedType<int>) is causing problems for the SayHello virtual method call. Since IL2CPP is an AOT compiler, and there is no source code for the GenericDerivedType<int> type, IL2CPP did not generate an implementation of the SayHello method.

GenericDerivedType<int>类型是动态创建的，它导致了SayHello虚函数调用出问题。因为IL2CPP是一个AOT的编译器，没有GenericDerivedType<int>类型的代码，IL2CPP没法儿创建SayHello的实现。

### **When you call a method that does not exist**

To understand what is happening here, we can create an [exception breakpoint](http://blogs.unity3d.com/2015/05/20/il2cpp-internals-debugging-tips-for-generated-code/) in Xcode. That breakpoint is triggered inside the il2cpp::vm::Runtime::GetVirtualInvokeData function, where the libil2cpp runtime is attempting to resolve the virtual method to call. That function looks like this:

我们深入看一下IL2CPP生成的C++的代码。

![Smaller icon](http://amgoodlife.top/images/11/original_invoke.png)

The first line does the lookup in the vtable that we discussed above. The second checks to see if the virtual method really exists, and throws the managed exception we saw if the method does not exist.

函数里的第一行代码查找了虚函数表，第二行检查了虚函数是否存在，最后一行代码丢出了异常如果虚方法不存在的时候。

### **Let’s make this code faster**

让代码运行的更快一些。

With only three lines of code here, can we make this any faster? As it turns out, we can! The vtable lookup is necessary, so that has to stay as-is. But what about that if check? Most of the time, the condition will be false (after all, look at the ugly code we needed to use to create a type at runtime and make the condition true). So why should we pay the cost of a branch in the code that we will seldom (or never) take?

Instead, let’s *always* call a method! When that method is not generated by the AOT compiler, we’ll replace it with a method that throws a managed exception. In Unity 5.5 (currently in closed alpha release), GetVirtualInvokeData looks like this:

只有三行代码，怎么能更开呢？当然能！查找vtable是必须的，留着。但是检查If函数呢？大部分时候，实际是不需要的。所以为什么我们要承担很少或从不执行的分支代码开销呢？

相反的，保证一直能有可调用的函数。这个函数不是AOT编译器生成的，我们用一个会抛出异常的函数来代替。

![Smaller icon](http://amgoodlife.top/images/11/newvir.png)

IL2CPP now generates a [stub] method for every different *function signature* used by any virtual method in the project. If a vtable slot doesn’t have a real method, it gets the proper stub method matching its function signature. In this case, the virtual method we call is:

IL2CPP现在会为每个不同签名的虚函数生成一个桩函数。如果vtable没有一个实际的函数，它会得到一个匹配签名的桩函数，这种情况下，下面的虚函数是这样的：

![Smaller icon](http://amgoodlife.top/images/11/newunre.png)

So the code behaves in the same way, throwing a proper managed exception when the AOT compiler was not able to generate code for a virtual method call. Most importantly though, this behavior now has *no cost* for the normal case.

代码的行为是一致的，当AOT编译器调用虚函数而找不到合适的时候，会丢出一个托管的异常。重要的是，这个行为却没有消耗。（应该有点内存上的代价）

### **How much faster is this?**

Now for the bottom line:** Does this micro-optimization matter? Yes**. Our profiling has shown between 3% – 4% improvement in *overall* execution time. The improvement varies depending on the number of virtual calls being made and processor architecture. Processors with better branch prediction pay a lower cost for the if check, so they see less benefit when it is removed. Processors that don’t handle branch prediction as well get a larger benefit in performance.

这么微小的优化有用吗？答案是当然有效。我们的profiling显示有大约3%-4%的整体运行提升。当然提升的效果依赖于调用虚函数的次数和处理器的架构。如果处理器对预测比较好，那么提升的效能就较少。相反的我们能获得很大的提升如果处理器对代码分枝的预测能力不强。

This is actually a common optimization technique for virtual machines, so we’re happy to be able to bring it to IL2CPP as well. It follows the old performance mantra, “executing no code is better than executing some code.”

我们很高兴把这个常见的优化技术带入IL2CPP。它遵循来一个古老的性能准则：**executing no code is better than executing some code.**

[文章]:http://amgoodlife.top/devirtualization/
[这里]:http://amgoodlife.top/il2cpp_introduce/
[stub]:https://zh.wikipedia.org/wiki/桩_(计算机)